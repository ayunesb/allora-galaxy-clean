
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from '../../types/supabase';
import { toast } from "@/components/ui/sonner";

const SUPABASE_URL = "https://ijrnwpgsqsxzqdemtknz.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imlqcm53cGdzcXN4enFkZW10a256Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY1ODM4MTgsImV4cCI6MjA2MjE1OTgxOH0.aIwahrPEK098sxdqAvsAJBDRCvyQpa9tb42gYn1hoRo";

// Create the Supabase client
const originalClient = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Network connectivity tracking
let isOffline = false;
let reconnectTimer: number | null = null;
let offlineOperations: Array<() => Promise<void>> = [];

// Check if we're in a browser environment
const isBrowser = typeof window !== 'undefined';

// Setup connectivity monitoring if in browser
if (isBrowser) {
  window.addEventListener('online', handleOnline);
  window.addEventListener('offline', handleOffline);
  
  // Initial check
  isOffline = !navigator.onLine;
}

function handleOffline() {
  isOffline = true;
  toast.error("You are offline. Changes will sync when connection is restored.");
}

function handleOnline() {
  if (isOffline) {
    isOffline = false;
    toast.success("You're back online! Syncing changes...");
    
    // Process any queued offline operations
    processOfflineOperations();
  }
}

async function processOfflineOperations() {
  if (offlineOperations.length === 0) return;
  
  const operations = [...offlineOperations];
  offlineOperations = [];
  
  for (const operation of operations) {
    try {
      await operation();
    } catch (error) {
      console.error("Failed to process offline operation:", error);
    }
  }
  
  if (offlineOperations.length === 0) {
    toast.success("All changes synced successfully!");
  } else {
    toast.warning(`${offlineOperations.length} operations still pending sync.`);
  }
}

// Export enhanced Supabase client with error handling
export const supabase = {
  ...originalClient,
  
  // Retry mechanism for important operations
  async retryOperation<T>(
    operation: () => Promise<T>,
    options = { maxRetries: 3, delayMs: 1000 }
  ): Promise<T> {
    let lastError: any;
    
    for (let attempt = 0; attempt <= options.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        
        if (attempt < options.maxRetries) {
          console.warn(`Operation failed, retrying (${attempt + 1}/${options.maxRetries})...`, error);
          // Exponential backoff
          await new Promise(resolve => setTimeout(resolve, options.delayMs * Math.pow(2, attempt)));
        }
      }
    }
    
    throw lastError;
  },
  
  // Queue operation for offline processing
  queueOfflineOperation(operation: () => Promise<void>) {
    offlineOperations.push(operation);
  },
  
  // Check connection status
  isOffline: () => isOffline
};

// Add manual network status check function
export function checkNetworkStatus() {
  if (isBrowser && navigator.onLine !== !isOffline) {
    if (navigator.onLine) {
      handleOnline();
    } else {
      handleOffline();
    }
  }
  return !isOffline;
}

// Periodically check for reconnection if offline
export function startReconnectionCheck() {
  if (reconnectTimer === null && isOffline) {
    reconnectTimer = window.setInterval(() => {
      // Try a simple fetch to check connection
      fetch(SUPABASE_URL, { method: 'HEAD', mode: 'no-cors' })
        .then(() => {
          if (isOffline) handleOnline();
        })
        .catch(() => {
          // Still offline, do nothing
        });
    }, 10000) as unknown as number;
  }
}

export function stopReconnectionCheck() {
  if (reconnectTimer !== null) {
    clearInterval(reconnectTimer);
    reconnectTimer = null;
  }
}
